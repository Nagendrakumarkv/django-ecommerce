Here is your 15-Day E-Commerce Sprint Plan.

Phase 1: The Foundation & "The Mall" (Days 1-4)
Focus: Setting up the database correctly and displaying products.

Day 1: Architecture & Auth. Setup Django, create a Custom User Model (crucial for e-commerce), and set up the app structure (store, accounts, cart).

Day 2: The Catalog (Models). Create Category and Product models. Handle product images (Pillow library) and prices.

Day 3: The Storefront. Build the Homepage and "All Products" page. Learn Django's ListView.
 
Day 4: Product Details. Build the individual product page (DetailView) with specifications, stock status, and related items.

Phase 2: The Shopping Cart (Days 5-7)
Focus: Managing temporary data (sessions) and cart logic.

Day 5: The Cart Logic. Design the Cart and CartItem models. Learn how to store cart ID in the browser session so non-logged-in users can shop.

Day 6: Add/Remove Actions. Create the views to "Add to Cart", "Remove Item", and "Update Quantity" via AJAX (no page reloads) or simple redirects.

Day 7: The Cart Page. Build the UI to show the summary, total price calculation, and "Proceed to Checkout" button.

Phase 3: Checkout & Orders (Days 8-11)
Focus: The hardest part—converting a Cart into a permanent Order.

Day 8: Checkout Forms. Create forms for Shipping Address and Billing info.

Day 9: The Order Model. Create Order and OrderItem models. This is where money meets data.

Day 10: Placing the Order. The logic to move items from Cart → Order, freeze the price (so future price changes don't affect old orders), and clear the cart.

Day 11: User Dashboard. A profile page where users can see their "Order History" and status (Pending, Shipped).

Phase 4: Payments & Search (Days 12-13)
Focus: Real-world integration.

Day 12: Payment Gateway. Integrate Stripe or Razorpay (Test Mode). We will learn how to handle webhooks (signals from the bank).

Day 13: Search & Filter. Add a search bar and sidebar filters (Price range, Categories).

Phase 5: Polish & Deploy (Days 14-15)
Focus: Make it look like Flipkart.

Day 14: UI/UX Overhaul. extensive Bootstrap styling. specific "Cards" for products, Badges for discounts, and a professional Navbar.

Day 15: Deployment. Push code to GitHub and deploy the app live (using Render or Railway).

Prerequisites Checklist
Since this is more complex, we need a few extra tools installed:

Pillow: Image processing library (pip install Pillow).

Stripe/Razorpay Account: (Free developer account) for Day 12.

Git: To save your progress daily.

---------------------------------------------------------------------------------------------------
Day 1: Architecture & Auth. Setup Django, create a Custom User Model (crucial for e-commerce), and set up the app structure (store, accounts, cart).

We need a solid folder structure because this app will have many moving parts.

Step 1: Setup Project & Virtual Env

# Create folder
mkdir django_flipkart
cd django_flipkart

# Virtual Env
python -m venv venv
# Activate it (Windows: venv\Scripts\activate | Mac: source venv/bin/activate)

# Install Django and Pillow (for images)
pip install django Pillow

# Start Project
django-admin startproject myproject .

Step 2: Create Modular Apps Instead of one big app, we split functionality (Micro-app architecture).

python manage.py startapp store      # Handles Products & Categories
python manage.py startapp accounts   # Handles Users & Login
python manage.py startapp carts      # Handles the Cart logic
python manage.py startapp orders     # Handles Checkout & History

Step 3: Register Apps & Media Settings

Open settings.py. Add the apps to INSTALLED_APPS:

INSTALLED_APPS = [
    # ... defaults ...
    'store',
    'accounts',
    'carts',
    'orders',
]

Crucial for E-commerce: Configure Media (Product Images). At the bottom of settings.py:

import os

STATIC_URL = 'static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# Where uploaded images go
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

Connect URLs for Media. Open myproject/urls.py:

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    # We will include app URLs later
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

Step 4: The Custom User Model (Theory) Standard Django uses username. E-commerce usually uses email to login. We should set this up today because changing the User model after migrating the database is a nightmare.

Step 2: The Custom User Model (The Logic)

We need to tell Django: "Ignore your default User model. Use my custom 'Account' model instead."

Open accounts/models.py.

Delete everything and paste this robust code. This creates a user that logs in with an Email:

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager

# 1. The Manager (Handles creating users)
class MyAccountManager(BaseUserManager):
    def create_user(self, first_name, last_name, username, email, password=None):
        if not email:
            raise ValueError('User must have an email address')
        if not username:
            raise ValueError('User must have an username')

        user = self.model(
            email = self.normalize_email(email), # Converts uppercase to lowercase
            username = username,
            first_name = first_name,
            last_name = last_name,
        )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, first_name, last_name, email, username, password):
        user = self.create_user(
            email = self.normalize_email(email),
            username = username,
            password = password,
            first_name = first_name,
            last_name = last_name,
        )
        # Superuser permissions
        user.is_admin = True
        user.is_active = True
        user.is_staff = True
        user.is_superadmin = True
        user.save(using=self._db)
        return user

# 2. The Model (The Database Table)
class Account(AbstractBaseUser):
    first_name      = models.CharField(max_length=50)
    last_name       = models.CharField(max_length=50)
    username        = models.CharField(max_length=50, unique=True)
    email           = models.EmailField(max_length=100, unique=True)
    phone_number    = models.CharField(max_length=50)

    # Required default fields
    date_joined     = models.DateTimeField(auto_now_add=True)
    last_login      = models.DateTimeField(auto_now_add=True)
    is_admin        = models.BooleanField(default=False)
    is_staff        = models.BooleanField(default=False)
    is_active       = models.BooleanField(default=False)
    is_superadmin   = models.BooleanField(default=False)

    # Tell Django to use Email as the login username
    USERNAME_FIELD  = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']

    objects = MyAccountManager()

    def __str__(self):
        return self.email

    # Permissions (Boilerplate)
    def has_perm(self, perm, obj=None):
        return self.is_admin

    def has_module_perms(self, add_label):
        return True

Step 3: Activate the Model
We wrote the code, but Django doesn't know it should use this class for authentication yet.

Open myproject/settings.py.

Add this line anywhere (usually at the bottom):

AUTH_USER_MODEL = 'accounts.Account'

Step 4: Fix the Admin Panel
Because we changed the User model, the default Django Admin panel will crash if we try to view Users. We need to tell the Admin how to display our new Account model.

Open accounts/admin.py.

Paste this code (This makes the password read-only and organizes the columns):

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import Account

class AccountAdmin(UserAdmin):
    list_display = ('email', 'first_name', 'last_name', 'username', 'last_login', 'date_joined', 'is_active')
    list_display_links = ('email', 'first_name', 'last_name')
    readonly_fields = ('last_login', 'date_joined')
    ordering = ('-date_joined',)

    # Essential for Custom User Model to work in Admin
    filter_horizontal = ()
    list_filter = ()
    fieldsets = ()

admin.site.register(Account, AccountAdmin)

Step 5: Migrations (The Moment of Truth)
This is where we commit our new architecture to the database.

Make Migrations:

python manage.py makemigrations

You should see: Create model Account

Migrate:

python manage.py migrate

Create Superuser: Now, test if it asks for Email instead of Username!

python manage.py createsuperuser

It should prompt:

First name:

Last name:

Email: (This is now your login ID)

Username:

Password:

Step 6: Verify Day 1
Run server: python manage.py runserver.

Go to http://127.0.0.1:8000/admin.

Login with the Email and password you just created.

Inside the Admin, you should see a section "Accounts". Click it, and you will see your user listed with their email address.

Did you successfully login to the admin panel using your Email? If yes, your Custom Auth system is live. This is the hardest configuration step, so great job getting past it!

-------------------------------------------------------------------------------------------------

Day 2: The Catalog (Models). Create Category and Product models. Handle product images (Pillow library) and prices.

This is where the app starts to feel real. Today, we define what we are actually selling.

Day 2 Goal: Build the Category and Product models so we can add items to our database.

We need to handle Relationships:

One Category (e.g., "Electronics") has Many Products (e.g., iPhone, Dell Laptop).

This is a One-to-Many relationship (ForeignKey).

Step 1: The Category Model
We need categories to organize products. We will also use Slugs.

What is a Slug? It's the URL-friendly version of a name.

Name: "T-Shirts & Tops" -> Slug: t-shirts-tops

URL: myshop.com/store/t-shirts-tops

Open store/models.py.

Add this code:

from django.db import models
from django.urls import reverse

class Category(models.Model):
    category_name = models.CharField(max_length=50, unique=True)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(max_length=255, blank=True)
    cat_image = models.ImageField(upload_to='photos/categories', blank=True)

    class Meta:
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def get_url(self):
        # We will use this later to link to the category page
        return reverse('products_by_category', args=[self.slug])

    def __str__(self):
        return self.category_name

Step 2: The Product Model
Now, the main event. This model holds all the details of the item.

In the same file (store/models.py), add the Product class below Category:

class Product(models.Model):
    product_name    = models.CharField(max_length=200, unique=True)
    slug            = models.SlugField(max_length=200, unique=True)
    description     = models.TextField(max_length=500, blank=True)
    price           = models.IntegerField()
    images          = models.ImageField(upload_to='photos/products')
    stock           = models.IntegerField()
    is_available    = models.BooleanField(default=True)

    # The Link: Delete product if category is deleted (CASCADE)
    category        = models.ForeignKey(Category, on_delete=models.CASCADE) 

    created_date    = models.DateTimeField(auto_now_add=True)
    modified_date   = models.DateTimeField(auto_now=True)

    def get_url(self):
        # Link to product detail page
        return reverse('product_detail', args=[self.category.slug, self.slug])

    def __str__(self):
        return self.product_name

Step 3: Supercharge the Admin Panel
We want the "Slug" field to be filled in automatically when we type the "Product Name".

Open store/admin.py.

Register the models with prepopulated_fields:

from django.contrib import admin
from .models import Product, Category

class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('category_name',)}
    list_display = ('category_name', 'slug')

class ProductAdmin(admin.ModelAdmin):
    list_display = ('product_name', 'price', 'stock', 'category', 'modified_date', 'is_available')
    prepopulated_fields = {'slug': ('product_name',)}

admin.site.register(Category, CategoryAdmin)
admin.site.register(Product, ProductAdmin)

Step 4: Database Sync
We created new models, so we must update the database.

Make Migrations:

python manage.py makemigrations

Output: Create model Category, Create model Product

Migrate:

python manage.py migrate

Step 5: Add Real Data (Crucial)
For the next few days to make sense, we need data to look at.

Run the server: python manage.py runserver

Go to http://127.0.0.1:8000/admin

Add Categories:

Create "Shirts" (Upload a random image if you have one).

Create "Shoes".

Notice how the 'Slug' field fills itself automatically? That's the admin magic.

Add Products:

Add "Blue Shirt" -> Category: Shirts -> Price: 20 -> Stock: 100

Add "Running Shoes" -> Category: Shoes -> Price: 50 -> Stock: 20

Step 6: Verify Day 2
Go to your media folder in your project directory (the one we set up in settings.py). Do you see a folder structure like media/photos/products containing the images you just uploaded?

If yes, your file upload system and database are perfectly linked.

Ready for Day 3? We will take this data and build the "Storefront" (The Homepage) so customers can actually see it.

-------------------------------------------------------------------------------------------------

Day 3: The Storefront. Build the Homepage and "All Products" page. Learn Django's ListView.

Day 3 Goal: Create the "Storefront" (Homepage) and the "Store" page to display our products to the world.

To do this, we need to fetch data from the database and display it in a grid.

Step 1: Configure Global Templates
Since the "Homepage" doesn't belong to a specific app (it's the face of the whole website), we need a central place for HTML files.

Create a folder named templates in your main project folder (the one containing manage.py).

Open myproject/settings.py.

Find the TEMPLATES section and add BASE_DIR / 'templates' to the 'DIRS' list:

'DIRS': ['templates'], # <--- Change this line

Step 2: The Home View (Landing Page)
Let's create the logic for the homepage. We usually show "Featured Products" here.

Create a new file myproject/views.py (inside the folder that has settings.py).

Add this code:

from django.shortcuts import render
from store.models import Product

def home(request):
    # Fetch valid products (not out of stock or hidden)
    products = Product.objects.all().filter(is_available=True)

    context = {
        'products': products,
    }
    return render(request, 'home.html', context)

Step 3: The Store View (Catalog Page)
Now let's create the logic for the main store page (/store/). This will eventually have filters, but for now, it lists everything.

Open store/views.py.

Add this code:

from django.shortcuts import render, get_object_or_404
from .models import Product

def store(request):
    products = Product.objects.all().filter(is_available=True)
    product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)

Step 4: The URLs (Routing)
We need to connect these views.

App URLs: Create a new file store/urls.py.

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
]

Project URLs: Open myproject/urls.py. connect the Home view and the Store app.

from django.contrib import admin
from django.urls import path, include
from . import views  # Import the home view from current folder

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.home, name='home'),          # Homepage
    path('store/', include('store.urls')),      # Store routes
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) # (Ensure media is still here)

Step 5: The Templates (The HTML)
We will create a base.html so we don't repeat the Navbar code.

Base Template: Create templates/base.html. Include Bootstrap for instant styling.

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Flipkart Clone</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Simple custom CSS for product cards */
        .card-img-top { object-fit: cover; height: 250px; }
    </style>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-primary">
  <div class="container">
    <a class="navbar-brand" href="{% url 'home' %}">BrandName</a>
    <div class="navbar-nav ms-auto">
        <a class="nav-link" href="{% url 'store' %}">Store</a>
        <a class="nav-link" href="#">Cart</a>
        <a class="nav-link" href="#">Login</a>
    </div>
  </div>
</nav>

{% block content %}
{% endblock %}

</body>
</html>

Home Template: Create templates/home.html.

{% extends 'base.html' %}
{% block content %}

<div class="bg-light p-5 mb-4 rounded-3 text-center">
    <h1>Welcome to the Store</h1>
    <p>Best products at best prices.</p>
    <a href="{% url 'store' %}" class="btn btn-primary">Shop Now</a>
</div>

<div class="container">
    <h2 class="text-center mb-4">Popular Products</h2>
    <div class="row">
        {% for product in products %}
        <div class="col-md-3 mb-4">
            <div class="card h-100">
                <img src="{{ product.images.url }}" class="card-img-top" alt="{{ product.product_name }}">
                <div class="card-body">
                    <h5 class="card-title">{{ product.product_name }}</h5>
                    <p class="card-text">${{ product.price }}</p>
                    <a href="{{ product.get_url }}" class="btn btn-primary btn-sm">View Details</a>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

Store Template: Create store/templates/store/store.html. (Note the nested folder structure: store app -> templates folder -> store folder -> file)

{% extends 'base.html' %}
{% block content %}
<div class="container mt-4">
    <div class="row">
        <aside class="col-md-3">
            <div class="card">
                <article class="card-group-item">
                    <header class="card-header"><h6>Categories</h6></header>
                </article>
            </div>
        </aside>

        <main class="col-md-9">
            <header class="border-bottom mb-4 pb-3">
                <span class="mr-md-auto">{{ product_count }} Items found </span>
            </header>

            <div class="row">
                {% for product in products %}
                <div class="col-md-4 mb-4">
                    <div class="card h-100">
                        <a href="{{ product.get_url }}">
                            <img src="{{ product.images.url }}" class="card-img-top">
                        </a>
                        <div class="card-body">
                            <h5 class="card-title">{{ product.product_name }}</h5>
                            <p class="card-text fw-bold">${{ product.price }}</p>
                            <a href="{{ product.get_url }}" class="btn btn-outline-primary btn-block">View Details</a>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </main>
    </div>
</div>
{% endblock %}

Step 6: Verify Day 3
Run server: python manage.py runserver.

Go to http://127.0.0.1:8000/. Do you see the "Popular Products"?

Click "Shop Now" or go to http://127.0.0.1:8000/store/. Do you see the sidebar layout?

Note: If your images are broken (showing a little torn icon), ensure you actually uploaded images in the admin panel and that your MEDIA settings from Day 1 are correct.

Ready for Day 4? We will click "View Details" and build the specific product page.

-------------------------------------------------------------------------------------------------

Day 4: Product Details. Build the individual product page (DetailView) with specifications, stock status, and related items.

This is a critical day. The "Product Detail" page is where the decision to buy happens.

Day 4 Goal: specific product page (DetailView) that handles:

Unique URLs: store/category-name/product-name

Stock Logic: Show "Out of Stock" if the count is 0.

Layout: Professional split-screen (Image vs. Details).

Step 1: The View (The Logic)
We need to fetch a single product. To be safe, we look it up using both the category slug and the product slug. This ensures unique URLs like /store/shoes/nike-air vs /store/shirts/nike-air.

Open store/views.py.

Import Category and add the product_detail function.

from django.shortcuts import render, get_object_or_404
from .models import Product, Category

# ... keep your existing store view ...

def product_detail(request, category_slug, product_slug):
    try:
        # 1. Get the product ensuring it exists in that specific category
        single_product = Product.objects.get(category__slug=category_slug, slug=product_slug)
    except Exception as e:
        raise e # Or redirect to 404 page

    context = {
        'single_product': single_product,
    }
    return render(request, 'store/product_detail.html', context)

Step 2: The URL (The Map)
We need to capture two dynamic values from the browser address bar.

Open store/urls.py.

Add the new path with <slug:category_slug> and <slug:product_slug>.

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
    path('category/<slug:category_slug>/', views.store, name='products_by_category'), # Filter by category
    path('category/<slug:category_slug>/<slug:product_slug>/', views.product_detail, name='product_detail'), # Specific Product
]

Note: I also added products_by_category. We will update the store view to handle this in a second.

Step 3: Update Store View for Categories
We just added a URL for filtering by category (e.g., /store/category/shirts/), but our store view doesn't handle it yet.

Update store/views.py. Modify the store function to accept an optional category_slug.

def store(request, category_slug=None):
    categories = None
    products = None

    if category_slug != None:
        # Filter by Category
        categories = get_object_or_404(Category, slug=category_slug)
        products = Product.objects.filter(category=categories, is_available=True)
        product_count = products.count()
    else:
        # Show All
        products = Product.objects.all().filter(is_available=True)
        product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)

Step 4: The Template (The Interface)
Now, the main event. We create the detail page.

Create store/templates/store/product_detail.html.

Use this Bootstrap layout:

{% extends 'base.html' %}
{% block content %}

<div class="container mt-5 mb-5">
    <div class="card">
        <div class="row g-0">
            <aside class="col-md-6 border-end">
                <article class="gallery-wrap"> 
                    <div class="img-big-wrap text-center p-4">
                        <img src="{{ single_product.images.url }}" class="img-fluid" style="max-height: 500px;">
                    </div> 
                </article> 
            </aside>

            <main class="col-md-6 border-start">
                <article class="content-body p-4">

                    <h2 class="title">{{ single_product.product_name }}</h2>

                    <div class="mb-3"> 
                        <var class="price h4">${{ single_product.price }}</var> 
                    </div> 

                    <p>{{ single_product.description }}</p>

                    <hr>

                    <div class="mb-3">
                        {% if single_product.stock <= 0 %}
                            <h5 class="text-danger">Out of Stock</h5>
                        {% else %}
                            <a href="#" class="btn  btn-primary"> 
                                <span class="text">Add to cart</span> 
                                <i class="fas fa-shopping-cart"></i> 
                            </a>
                        {% endif %}
                    </div>

                </article> 
            </main>
        </div>
    </div>
</div>
{% endblock %}

Step 5: Link the Pages
We need to make sure clicking a product on the Homepage or Store page actually takes us here.

Check store.html and home.html: Look for the <a> tag around the product image or name. Ensure it uses product.get_url.

<a href="{{ product.get_url }}">{{ product.product_name }}</a>

Why this works: In Day 2, we defined def get_url(self) inside the Product model. It automatically generates the correct /store/category/product/ link for us.

This is a critical day. The "Product Detail" page is where the decision to buy happens.

Day 4 Goal: specific product page (DetailView) that handles:

Unique URLs: store/category-name/product-name

Stock Logic: Show "Out of Stock" if the count is 0.

Layout: Professional split-screen (Image vs. Details).

Step 1: The View (The Logic)
We need to fetch a single product. To be safe, we look it up using both the category slug and the product slug. This ensures unique URLs like /store/shoes/nike-air vs /store/shirts/nike-air.

Open store/views.py.

Import Category and add the product_detail function.

Python

from django.shortcuts import render, get_object_or_404
from .models import Product, Category

# ... keep your existing store view ...

def product_detail(request, category_slug, product_slug):
    try:
        # 1. Get the product ensuring it exists in that specific category
        single_product = Product.objects.get(category__slug=category_slug, slug=product_slug)
    except Exception as e:
        raise e # Or redirect to 404 page

    context = {
        'single_product': single_product,
    }
    return render(request, 'store/product_detail.html', context)
Step 2: The URL (The Map)
We need to capture two dynamic values from the browser address bar.

Open store/urls.py.

Add the new path with <slug:category_slug> and <slug:product_slug>.

Python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
    path('category/<slug:category_slug>/', views.store, name='products_by_category'), # Filter by category
    path('category/<slug:category_slug>/<slug:product_slug>/', views.product_detail, name='product_detail'), # Specific Product
]
Note: I also added products_by_category. We will update the store view to handle this in a second.

Step 3: Update Store View for Categories
We just added a URL for filtering by category (e.g., /store/category/shirts/), but our store view doesn't handle it yet.

Update store/views.py. Modify the store function to accept an optional category_slug.

Python

def store(request, category_slug=None):
    categories = None
    products = None

    if category_slug != None:
        # Filter by Category
        categories = get_object_or_404(Category, slug=category_slug)
        products = Product.objects.filter(category=categories, is_available=True)
        product_count = products.count()
    else:
        # Show All
        products = Product.objects.all().filter(is_available=True)
        product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)
Step 4: The Template (The Interface)
Now, the main event. We create the detail page.

Create store/templates/store/product_detail.html.

Use this Bootstrap layout:

HTML

{% extends 'base.html' %}
{% block content %}

<div class="container mt-5 mb-5">
    <div class="card">
        <div class="row g-0">
            <aside class="col-md-6 border-end">
                <article class="gallery-wrap"> 
                    <div class="img-big-wrap text-center p-4">
                        <img src="{{ single_product.images.url }}" class="img-fluid" style="max-height: 500px;">
                    </div> 
                </article> 
            </aside>

            <main class="col-md-6 border-start">
                <article class="content-body p-4">

                    <h2 class="title">{{ single_product.product_name }}</h2>

                    <div class="mb-3"> 
                        <var class="price h4">${{ single_product.price }}</var> 
                    </div> 

                    <p>{{ single_product.description }}</p>

                    <hr>

                    <div class="mb-3">
                        {% if single_product.stock <= 0 %}
                            <h5 class="text-danger">Out of Stock</h5>
                        {% else %}
                            <a href="#" class="btn  btn-primary"> 
                                <span class="text">Add to cart</span> 
                                <i class="fas fa-shopping-cart"></i> 
                            </a>
                        {% endif %}
                    </div>

                </article> 
            </main>
        </div>
    </div>
</div>
{% endblock %}
Step 5: Link the Pages
We need to make sure clicking a product on the Homepage or Store page actually takes us here.

Check store.html and home.html: Look for the <a> tag around the product image or name. Ensure it uses product.get_url.

HTML

<a href="{{ product.get_url }}">{{ product.product_name }}</a>
Why this works: In Day 2, we defined def get_url(self) inside the Product model. It automatically generates the correct /store/category/product/ link for us.

Step 6: Verify Day 4
Run the server.

Go to the Store page.

Click on a product.

Success: You see the big image on the left, details on the right.

Success: The URL looks like /store/category/shirts/blue-shirt/.

Test Stock: Go to the Admin panel, change a product's stock to 0. Refresh the detail page. Does the button change to "Out of Stock"?

Phase 1 (The Foundation) is complete! You have a working catalog.

Ready for Phase 2 (The Shopping Cart)? This is where the logic gets tricky (Sessions & Math). start tomorrow?

-------------------------------------------------------------------------------------------------

Day 5: The Cart Logic. Design the Cart and CartItem models. Learn how to store cart ID in the browser session so non-logged-in users can shop.