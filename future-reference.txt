Here is your 15-Day E-Commerce Sprint Plan.

Phase 1: The Foundation & "The Mall" (Days 1-4)
Focus: Setting up the database correctly and displaying products.

Day 1: Architecture & Auth. Setup Django, create a Custom User Model (crucial for e-commerce), and set up the app structure (store, accounts, cart).

Day 2: The Catalog (Models). Create Category and Product models. Handle product images (Pillow library) and prices.

Day 3: The Storefront. Build the Homepage and "All Products" page. Learn Django's ListView.
 
Day 4: Product Details. Build the individual product page (DetailView) with specifications, stock status, and related items.

Phase 2: The Shopping Cart (Days 5-7)
Focus: Managing temporary data (sessions) and cart logic.

Day 5: The Cart Logic. Design the Cart and CartItem models. Learn how to store cart ID in the browser session so non-logged-in users can shop.

Day 6: Add/Remove Actions. Create the views to "Add to Cart", "Remove Item", and "Update Quantity" via AJAX (no page reloads) or simple redirects.

Day 7: The Cart Page. Build the UI to show the summary, total price calculation, and "Proceed to Checkout" button.

Phase 3: Checkout & Orders (Days 8-11)
Focus: The hardest part—converting a Cart into a permanent Order.

Day 8: Checkout Forms. Create forms for Shipping Address and Billing info.

Day 9: The Order Model. Create Order and OrderItem models. This is where money meets data.

Day 10: Placing the Order. The logic to move items from Cart → Order, freeze the price (so future price changes don't affect old orders), and clear the cart.

Day 11: User Dashboard. A profile page where users can see their "Order History" and status (Pending, Shipped).

Phase 4: Payments & Search (Days 12-13)
Focus: Real-world integration.

Day 12: Payment Gateway. Integrate Stripe or Razorpay (Test Mode). We will learn how to handle webhooks (signals from the bank).

Day 13: Search & Filter. Add a search bar and sidebar filters (Price range, Categories).

Phase 5: Polish & Deploy (Days 14-15)
Focus: Make it look like Flipkart.

Day 14: UI/UX Overhaul. extensive Bootstrap styling. specific "Cards" for products, Badges for discounts, and a professional Navbar.

Day 15: Deployment. Push code to GitHub and deploy the app live (using Render or Railway).

Prerequisites Checklist
Since this is more complex, we need a few extra tools installed:

Pillow: Image processing library (pip install Pillow).

Stripe/Razorpay Account: (Free developer account) for Day 12.

Git: To save your progress daily.

---------------------------------------------------------------------------------------------------
Day 1: Architecture & Auth. Setup Django, create a Custom User Model (crucial for e-commerce), and set up the app structure (store, accounts, cart).

We need a solid folder structure because this app will have many moving parts.

Step 1: Setup Project & Virtual Env

# Create folder
mkdir django_flipkart
cd django_flipkart

# Virtual Env
python -m venv venv
# Activate it (Windows: venv\Scripts\activate | Mac: source venv/bin/activate)

# Install Django and Pillow (for images)
pip install django Pillow

# Start Project
django-admin startproject myproject .

Step 2: Create Modular Apps Instead of one big app, we split functionality (Micro-app architecture).

python manage.py startapp store      # Handles Products & Categories
python manage.py startapp accounts   # Handles Users & Login
python manage.py startapp carts      # Handles the Cart logic
python manage.py startapp orders     # Handles Checkout & History

Step 3: Register Apps & Media Settings

Open settings.py. Add the apps to INSTALLED_APPS:

INSTALLED_APPS = [
    # ... defaults ...
    'store',
    'accounts',
    'carts',
    'orders',
]

Crucial for E-commerce: Configure Media (Product Images). At the bottom of settings.py:

import os

STATIC_URL = 'static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# Where uploaded images go
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

Connect URLs for Media. Open myproject/urls.py:

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    # We will include app URLs later
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

Step 4: The Custom User Model (Theory) Standard Django uses username. E-commerce usually uses email to login. We should set this up today because changing the User model after migrating the database is a nightmare.

Step 2: The Custom User Model (The Logic)

We need to tell Django: "Ignore your default User model. Use my custom 'Account' model instead."

Open accounts/models.py.

Delete everything and paste this robust code. This creates a user that logs in with an Email:

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager

# 1. The Manager (Handles creating users)
class MyAccountManager(BaseUserManager):
    def create_user(self, first_name, last_name, username, email, password=None):
        if not email:
            raise ValueError('User must have an email address')
        if not username:
            raise ValueError('User must have an username')

        user = self.model(
            email = self.normalize_email(email), # Converts uppercase to lowercase
            username = username,
            first_name = first_name,
            last_name = last_name,
        )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, first_name, last_name, email, username, password):
        user = self.create_user(
            email = self.normalize_email(email),
            username = username,
            password = password,
            first_name = first_name,
            last_name = last_name,
        )
        # Superuser permissions
        user.is_admin = True
        user.is_active = True
        user.is_staff = True
        user.is_superadmin = True
        user.save(using=self._db)
        return user

# 2. The Model (The Database Table)
class Account(AbstractBaseUser):
    first_name      = models.CharField(max_length=50)
    last_name       = models.CharField(max_length=50)
    username        = models.CharField(max_length=50, unique=True)
    email           = models.EmailField(max_length=100, unique=True)
    phone_number    = models.CharField(max_length=50)

    # Required default fields
    date_joined     = models.DateTimeField(auto_now_add=True)
    last_login      = models.DateTimeField(auto_now_add=True)
    is_admin        = models.BooleanField(default=False)
    is_staff        = models.BooleanField(default=False)
    is_active       = models.BooleanField(default=False)
    is_superadmin   = models.BooleanField(default=False)

    # Tell Django to use Email as the login username
    USERNAME_FIELD  = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']

    objects = MyAccountManager()

    def __str__(self):
        return self.email

    # Permissions (Boilerplate)
    def has_perm(self, perm, obj=None):
        return self.is_admin

    def has_module_perms(self, add_label):
        return True

Step 3: Activate the Model
We wrote the code, but Django doesn't know it should use this class for authentication yet.

Open myproject/settings.py.

Add this line anywhere (usually at the bottom):

AUTH_USER_MODEL = 'accounts.Account'

Step 4: Fix the Admin Panel
Because we changed the User model, the default Django Admin panel will crash if we try to view Users. We need to tell the Admin how to display our new Account model.

Open accounts/admin.py.

Paste this code (This makes the password read-only and organizes the columns):

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import Account

class AccountAdmin(UserAdmin):
    list_display = ('email', 'first_name', 'last_name', 'username', 'last_login', 'date_joined', 'is_active')
    list_display_links = ('email', 'first_name', 'last_name')
    readonly_fields = ('last_login', 'date_joined')
    ordering = ('-date_joined',)

    # Essential for Custom User Model to work in Admin
    filter_horizontal = ()
    list_filter = ()
    fieldsets = ()

admin.site.register(Account, AccountAdmin)

Step 5: Migrations (The Moment of Truth)
This is where we commit our new architecture to the database.

Make Migrations:

python manage.py makemigrations

You should see: Create model Account

Migrate:

python manage.py migrate

Create Superuser: Now, test if it asks for Email instead of Username!

python manage.py createsuperuser

It should prompt:

First name:

Last name:

Email: (This is now your login ID)

Username:

Password:

Step 6: Verify Day 1
Run server: python manage.py runserver.

Go to http://127.0.0.1:8000/admin.

Login with the Email and password you just created.

Inside the Admin, you should see a section "Accounts". Click it, and you will see your user listed with their email address.

Did you successfully login to the admin panel using your Email? If yes, your Custom Auth system is live. This is the hardest configuration step, so great job getting past it!

-------------------------------------------------------------------------------------------------

Day 2: The Catalog (Models). Create Category and Product models. Handle product images (Pillow library) and prices.

This is where the app starts to feel real. Today, we define what we are actually selling.

Day 2 Goal: Build the Category and Product models so we can add items to our database.

We need to handle Relationships:

One Category (e.g., "Electronics") has Many Products (e.g., iPhone, Dell Laptop).

This is a One-to-Many relationship (ForeignKey).

Step 1: The Category Model
We need categories to organize products. We will also use Slugs.

What is a Slug? It's the URL-friendly version of a name.

Name: "T-Shirts & Tops" -> Slug: t-shirts-tops

URL: myshop.com/store/t-shirts-tops

Open store/models.py.

Add this code:

from django.db import models
from django.urls import reverse

class Category(models.Model):
    category_name = models.CharField(max_length=50, unique=True)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(max_length=255, blank=True)
    cat_image = models.ImageField(upload_to='photos/categories', blank=True)

    class Meta:
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def get_url(self):
        # We will use this later to link to the category page
        return reverse('products_by_category', args=[self.slug])

    def __str__(self):
        return self.category_name

Step 2: The Product Model
Now, the main event. This model holds all the details of the item.

In the same file (store/models.py), add the Product class below Category:

class Product(models.Model):
    product_name    = models.CharField(max_length=200, unique=True)
    slug            = models.SlugField(max_length=200, unique=True)
    description     = models.TextField(max_length=500, blank=True)
    price           = models.IntegerField()
    images          = models.ImageField(upload_to='photos/products')
    stock           = models.IntegerField()
    is_available    = models.BooleanField(default=True)

    # The Link: Delete product if category is deleted (CASCADE)
    category        = models.ForeignKey(Category, on_delete=models.CASCADE) 

    created_date    = models.DateTimeField(auto_now_add=True)
    modified_date   = models.DateTimeField(auto_now=True)

    def get_url(self):
        # Link to product detail page
        return reverse('product_detail', args=[self.category.slug, self.slug])

    def __str__(self):
        return self.product_name

Step 3: Supercharge the Admin Panel
We want the "Slug" field to be filled in automatically when we type the "Product Name".

Open store/admin.py.

Register the models with prepopulated_fields:

from django.contrib import admin
from .models import Product, Category

class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('category_name',)}
    list_display = ('category_name', 'slug')

class ProductAdmin(admin.ModelAdmin):
    list_display = ('product_name', 'price', 'stock', 'category', 'modified_date', 'is_available')
    prepopulated_fields = {'slug': ('product_name',)}

admin.site.register(Category, CategoryAdmin)
admin.site.register(Product, ProductAdmin)

Step 4: Database Sync
We created new models, so we must update the database.

Make Migrations:

python manage.py makemigrations

Output: Create model Category, Create model Product

Migrate:

python manage.py migrate

Step 5: Add Real Data (Crucial)
For the next few days to make sense, we need data to look at.

Run the server: python manage.py runserver

Go to http://127.0.0.1:8000/admin

Add Categories:

Create "Shirts" (Upload a random image if you have one).

Create "Shoes".

Notice how the 'Slug' field fills itself automatically? That's the admin magic.

Add Products:

Add "Blue Shirt" -> Category: Shirts -> Price: 20 -> Stock: 100

Add "Running Shoes" -> Category: Shoes -> Price: 50 -> Stock: 20

Step 6: Verify Day 2
Go to your media folder in your project directory (the one we set up in settings.py). Do you see a folder structure like media/photos/products containing the images you just uploaded?

If yes, your file upload system and database are perfectly linked.

Ready for Day 3? We will take this data and build the "Storefront" (The Homepage) so customers can actually see it.

-------------------------------------------------------------------------------------------------

Day 3: The Storefront. Build the Homepage and "All Products" page. Learn Django's ListView.

Day 3 Goal: Create the "Storefront" (Homepage) and the "Store" page to display our products to the world.

To do this, we need to fetch data from the database and display it in a grid.

Step 1: Configure Global Templates
Since the "Homepage" doesn't belong to a specific app (it's the face of the whole website), we need a central place for HTML files.

Create a folder named templates in your main project folder (the one containing manage.py).

Open myproject/settings.py.

Find the TEMPLATES section and add BASE_DIR / 'templates' to the 'DIRS' list:

'DIRS': ['templates'], # <--- Change this line

Step 2: The Home View (Landing Page)
Let's create the logic for the homepage. We usually show "Featured Products" here.

Create a new file myproject/views.py (inside the folder that has settings.py).

Add this code:

from django.shortcuts import render
from store.models import Product

def home(request):
    # Fetch valid products (not out of stock or hidden)
    products = Product.objects.all().filter(is_available=True)

    context = {
        'products': products,
    }
    return render(request, 'home.html', context)

Step 3: The Store View (Catalog Page)
Now let's create the logic for the main store page (/store/). This will eventually have filters, but for now, it lists everything.

Open store/views.py.

Add this code:

from django.shortcuts import render, get_object_or_404
from .models import Product

def store(request):
    products = Product.objects.all().filter(is_available=True)
    product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)

Step 4: The URLs (Routing)
We need to connect these views.

App URLs: Create a new file store/urls.py.

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
]

Project URLs: Open myproject/urls.py. connect the Home view and the Store app.

from django.contrib import admin
from django.urls import path, include
from . import views  # Import the home view from current folder

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.home, name='home'),          # Homepage
    path('store/', include('store.urls')),      # Store routes
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) # (Ensure media is still here)

Step 5: The Templates (The HTML)
We will create a base.html so we don't repeat the Navbar code.

Base Template: Create templates/base.html. Include Bootstrap for instant styling.

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Flipkart Clone</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Simple custom CSS for product cards */
        .card-img-top { object-fit: cover; height: 250px; }
    </style>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-primary">
  <div class="container">
    <a class="navbar-brand" href="{% url 'home' %}">BrandName</a>
    <div class="navbar-nav ms-auto">
        <a class="nav-link" href="{% url 'store' %}">Store</a>
        <a class="nav-link" href="#">Cart</a>
        <a class="nav-link" href="#">Login</a>
    </div>
  </div>
</nav>

{% block content %}
{% endblock %}

</body>
</html>

Home Template: Create templates/home.html.

{% extends 'base.html' %}
{% block content %}

<div class="bg-light p-5 mb-4 rounded-3 text-center">
    <h1>Welcome to the Store</h1>
    <p>Best products at best prices.</p>
    <a href="{% url 'store' %}" class="btn btn-primary">Shop Now</a>
</div>

<div class="container">
    <h2 class="text-center mb-4">Popular Products</h2>
    <div class="row">
        {% for product in products %}
        <div class="col-md-3 mb-4">
            <div class="card h-100">
                <img src="{{ product.images.url }}" class="card-img-top" alt="{{ product.product_name }}">
                <div class="card-body">
                    <h5 class="card-title">{{ product.product_name }}</h5>
                    <p class="card-text">${{ product.price }}</p>
                    <a href="{{ product.get_url }}" class="btn btn-primary btn-sm">View Details</a>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

Store Template: Create store/templates/store/store.html. (Note the nested folder structure: store app -> templates folder -> store folder -> file)

{% extends 'base.html' %}
{% block content %}
<div class="container mt-4">
    <div class="row">
        <aside class="col-md-3">
            <div class="card">
                <article class="card-group-item">
                    <header class="card-header"><h6>Categories</h6></header>
                </article>
            </div>
        </aside>

        <main class="col-md-9">
            <header class="border-bottom mb-4 pb-3">
                <span class="mr-md-auto">{{ product_count }} Items found </span>
            </header>

            <div class="row">
                {% for product in products %}
                <div class="col-md-4 mb-4">
                    <div class="card h-100">
                        <a href="{{ product.get_url }}">
                            <img src="{{ product.images.url }}" class="card-img-top">
                        </a>
                        <div class="card-body">
                            <h5 class="card-title">{{ product.product_name }}</h5>
                            <p class="card-text fw-bold">${{ product.price }}</p>
                            <a href="{{ product.get_url }}" class="btn btn-outline-primary btn-block">View Details</a>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </main>
    </div>
</div>
{% endblock %}

Step 6: Verify Day 3
Run server: python manage.py runserver.

Go to http://127.0.0.1:8000/. Do you see the "Popular Products"?

Click "Shop Now" or go to http://127.0.0.1:8000/store/. Do you see the sidebar layout?

Note: If your images are broken (showing a little torn icon), ensure you actually uploaded images in the admin panel and that your MEDIA settings from Day 1 are correct.

Ready for Day 4? We will click "View Details" and build the specific product page.

-------------------------------------------------------------------------------------------------

Day 4: Product Details. Build the individual product page (DetailView) with specifications, stock status, and related items.

This is a critical day. The "Product Detail" page is where the decision to buy happens.

Day 4 Goal: specific product page (DetailView) that handles:

Unique URLs: store/category-name/product-name

Stock Logic: Show "Out of Stock" if the count is 0.

Layout: Professional split-screen (Image vs. Details).

Step 1: The View (The Logic)
We need to fetch a single product. To be safe, we look it up using both the category slug and the product slug. This ensures unique URLs like /store/shoes/nike-air vs /store/shirts/nike-air.

Open store/views.py.

Import Category and add the product_detail function.

from django.shortcuts import render, get_object_or_404
from .models import Product, Category

# ... keep your existing store view ...

def product_detail(request, category_slug, product_slug):
    try:
        # 1. Get the product ensuring it exists in that specific category
        single_product = Product.objects.get(category__slug=category_slug, slug=product_slug)
    except Exception as e:
        raise e # Or redirect to 404 page

    context = {
        'single_product': single_product,
    }
    return render(request, 'store/product_detail.html', context)

Step 2: The URL (The Map)
We need to capture two dynamic values from the browser address bar.

Open store/urls.py.

Add the new path with <slug:category_slug> and <slug:product_slug>.

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
    path('category/<slug:category_slug>/', views.store, name='products_by_category'), # Filter by category
    path('category/<slug:category_slug>/<slug:product_slug>/', views.product_detail, name='product_detail'), # Specific Product
]

Note: I also added products_by_category. We will update the store view to handle this in a second.

Step 3: Update Store View for Categories
We just added a URL for filtering by category (e.g., /store/category/shirts/), but our store view doesn't handle it yet.

Update store/views.py. Modify the store function to accept an optional category_slug.

def store(request, category_slug=None):
    categories = None
    products = None

    if category_slug != None:
        # Filter by Category
        categories = get_object_or_404(Category, slug=category_slug)
        products = Product.objects.filter(category=categories, is_available=True)
        product_count = products.count()
    else:
        # Show All
        products = Product.objects.all().filter(is_available=True)
        product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)

Step 4: The Template (The Interface)
Now, the main event. We create the detail page.

Create store/templates/store/product_detail.html.

Use this Bootstrap layout:

{% extends 'base.html' %}
{% block content %}

<div class="container mt-5 mb-5">
    <div class="card">
        <div class="row g-0">
            <aside class="col-md-6 border-end">
                <article class="gallery-wrap"> 
                    <div class="img-big-wrap text-center p-4">
                        <img src="{{ single_product.images.url }}" class="img-fluid" style="max-height: 500px;">
                    </div> 
                </article> 
            </aside>

            <main class="col-md-6 border-start">
                <article class="content-body p-4">

                    <h2 class="title">{{ single_product.product_name }}</h2>

                    <div class="mb-3"> 
                        <var class="price h4">${{ single_product.price }}</var> 
                    </div> 

                    <p>{{ single_product.description }}</p>

                    <hr>

                    <div class="mb-3">
                        {% if single_product.stock <= 0 %}
                            <h5 class="text-danger">Out of Stock</h5>
                        {% else %}
                            <a href="#" class="btn  btn-primary"> 
                                <span class="text">Add to cart</span> 
                                <i class="fas fa-shopping-cart"></i> 
                            </a>
                        {% endif %}
                    </div>

                </article> 
            </main>
        </div>
    </div>
</div>
{% endblock %}

Step 5: Link the Pages
We need to make sure clicking a product on the Homepage or Store page actually takes us here.

Check store.html and home.html: Look for the <a> tag around the product image or name. Ensure it uses product.get_url.

<a href="{{ product.get_url }}">{{ product.product_name }}</a>

Why this works: In Day 2, we defined def get_url(self) inside the Product model. It automatically generates the correct /store/category/product/ link for us.

This is a critical day. The "Product Detail" page is where the decision to buy happens.

Day 4 Goal: specific product page (DetailView) that handles:

Unique URLs: store/category-name/product-name

Stock Logic: Show "Out of Stock" if the count is 0.

Layout: Professional split-screen (Image vs. Details).

Step 1: The View (The Logic)
We need to fetch a single product. To be safe, we look it up using both the category slug and the product slug. This ensures unique URLs like /store/shoes/nike-air vs /store/shirts/nike-air.

Open store/views.py.

Import Category and add the product_detail function.

Python

from django.shortcuts import render, get_object_or_404
from .models import Product, Category

# ... keep your existing store view ...

def product_detail(request, category_slug, product_slug):
    try:
        # 1. Get the product ensuring it exists in that specific category
        single_product = Product.objects.get(category__slug=category_slug, slug=product_slug)
    except Exception as e:
        raise e # Or redirect to 404 page

    context = {
        'single_product': single_product,
    }
    return render(request, 'store/product_detail.html', context)
Step 2: The URL (The Map)
We need to capture two dynamic values from the browser address bar.

Open store/urls.py.

Add the new path with <slug:category_slug> and <slug:product_slug>.

Python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.store, name='store'),
    path('category/<slug:category_slug>/', views.store, name='products_by_category'), # Filter by category
    path('category/<slug:category_slug>/<slug:product_slug>/', views.product_detail, name='product_detail'), # Specific Product
]
Note: I also added products_by_category. We will update the store view to handle this in a second.

Step 3: Update Store View for Categories
We just added a URL for filtering by category (e.g., /store/category/shirts/), but our store view doesn't handle it yet.

Update store/views.py. Modify the store function to accept an optional category_slug.

Python

def store(request, category_slug=None):
    categories = None
    products = None

    if category_slug != None:
        # Filter by Category
        categories = get_object_or_404(Category, slug=category_slug)
        products = Product.objects.filter(category=categories, is_available=True)
        product_count = products.count()
    else:
        # Show All
        products = Product.objects.all().filter(is_available=True)
        product_count = products.count()

    context = {
        'products': products,
        'product_count': product_count,
    }
    return render(request, 'store/store.html', context)
Step 4: The Template (The Interface)
Now, the main event. We create the detail page.

Create store/templates/store/product_detail.html.

Use this Bootstrap layout:

HTML

{% extends 'base.html' %}
{% block content %}

<div class="container mt-5 mb-5">
    <div class="card">
        <div class="row g-0">
            <aside class="col-md-6 border-end">
                <article class="gallery-wrap"> 
                    <div class="img-big-wrap text-center p-4">
                        <img src="{{ single_product.images.url }}" class="img-fluid" style="max-height: 500px;">
                    </div> 
                </article> 
            </aside>

            <main class="col-md-6 border-start">
                <article class="content-body p-4">

                    <h2 class="title">{{ single_product.product_name }}</h2>

                    <div class="mb-3"> 
                        <var class="price h4">${{ single_product.price }}</var> 
                    </div> 

                    <p>{{ single_product.description }}</p>

                    <hr>

                    <div class="mb-3">
                        {% if single_product.stock <= 0 %}
                            <h5 class="text-danger">Out of Stock</h5>
                        {% else %}
                            <a href="#" class="btn  btn-primary"> 
                                <span class="text">Add to cart</span> 
                                <i class="fas fa-shopping-cart"></i> 
                            </a>
                        {% endif %}
                    </div>

                </article> 
            </main>
        </div>
    </div>
</div>
{% endblock %}
Step 5: Link the Pages
We need to make sure clicking a product on the Homepage or Store page actually takes us here.

Check store.html and home.html: Look for the <a> tag around the product image or name. Ensure it uses product.get_url.

HTML

<a href="{{ product.get_url }}">{{ product.product_name }}</a>
Why this works: In Day 2, we defined def get_url(self) inside the Product model. It automatically generates the correct /store/category/product/ link for us.

Step 6: Verify Day 4
Run the server.

Go to the Store page.

Click on a product.

Success: You see the big image on the left, details on the right.

Success: The URL looks like /store/category/shirts/blue-shirt/.

Test Stock: Go to the Admin panel, change a product's stock to 0. Refresh the detail page. Does the button change to "Out of Stock"?

Phase 1 (The Foundation) is complete! You have a working catalog.

Ready for Phase 2 (The Shopping Cart)? This is where the logic gets tricky (Sessions & Math). start tomorrow?

-------------------------------------------------------------------------------------------------

This is a big milestone. We are starting Phase 2: The Shopping Cart.

Day 5 Goal: Build the "Engine" of the cart. We need to allow users to add items to a cart without logging in.

How does that work? We use Sessions. When a user visits your site, Django gives them a unique "Session ID" (a cookie). We will use this ID to label their cart in the database.

Step 1: The Cart Models
We need two tables:

Cart: The actual shopping basket (linked to the session ID).

CartItem: The specific products inside that basket (linked to the Product).

Open carts/models.py.

Add this code:

Python

from django.db import models
from store.models import Product

class Cart(models.Model):
    cart_id = models.CharField(max_length=250, blank=True)
    date_added = models.DateField(auto_now_add=True)

    def __str__(self):
        return self.cart_id

class CartItem(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    cart    = models.ForeignKey(Cart, on_delete=models.CASCADE)
    quantity = models.IntegerField()
    is_active = models.BooleanField(default=True)

    def sub_total(self):
        # Helper to calculate price * quantity
        return self.product.price * self.quantity

    def __str__(self):
        return self.product.product_name
Step 2: Database Sync
We created new models, so we migrate.

Make Migrations:

Bash

python manage.py makemigrations
Output: Create model Cart, Create model CartItem

Migrate:

Bash

python manage.py migrate
Step 3: The Session Helper (Crucial Utility)
We need a small "private" function that checks if the user has a session ID. If not, it creates one.

Open carts/views.py.

Add this function at the very top (we will use it tomorrow):

Python

from django.shortcuts import render, redirect
from store.models import Product
from .models import Cart, CartItem

# Private function to get the session key (the "Cart ID")
def _cart_id(request):
    cart = request.session.session_key
    if not cart:
        cart = request.session.create()
    return cart
Note: The underscore _ at the start means it's a private helper function, not a view accessed by a URL.

Step 4: Register in Admin
We want to see carts being created in the backend.

Open carts/admin.py.

Python

from django.contrib import admin
from .models import Cart, CartItem

class CartItemAdmin(admin.ModelAdmin):
    list_display = ('product', 'cart', 'quantity', 'is_active')

admin.site.register(Cart)
admin.site.register(CartItem, CartItemAdmin)
Step 5: Verify Day 5
Since we haven't built the "Add to Cart" button logic yet, we can't test this on the frontend. But we can verify the structure.

Run the server.

Go to http://127.0.0.1:8000/admin.

Do you see the Carts app with Carts and Cart items?

If yes, the "Engine" is ready.

Tomorrow (Day 6) is the fun part: We connect the "Add to Cart" button to this engine using the _cart_id function we just wrote.

Ready to move on?

-------------------------------------------------------------------------------------------------

Day 6 Goal: Implement the logic for "Add to Cart", "Decrement Quantity", and "Remove Item".

We are writing the backend logic that handles the math when a user clicks buttons.

Step 1: The "Add to Cart" View
This function does the heavy lifting:

Gets the product.

Gets the cart (using the _cart_id helper from Day 5).

Checks if the item is already there (Quantity + 1) or if it's new (Create Item).

Open carts/views.py.

Add the add_cart function:

Python

from django.shortcuts import render, redirect, get_object_or_404
from store.models import Product
from .models import Cart, CartItem
from django.core.exceptions import ObjectDoesNotExist

# ... keep your _cart_id function here ...

def add_cart(request, product_id):
    # 1. Get the product
    product = Product.objects.get(id=product_id) 

    # 2. Get or Create the Cart (Session based)
    try:
        cart = Cart.objects.get(cart_id=_cart_id(request))
    except Cart.DoesNotExist:
        cart = Cart.objects.create(
            cart_id = _cart_id(request)
        )
    cart.save()

    # 3. Add the item to the cart
    try:
        cart_item = CartItem.objects.get(product=product, cart=cart)
        cart_item.quantity += 1 # If exists, increment
        cart_item.save()
    except CartItem.DoesNotExist:
        cart_item = CartItem.objects.create(
            product = product,
            quantity = 1,
            cart = cart,
        )
        cart_item.save()

    return redirect('cart') # Redirect to the cart page (we will build this next)
Step 2: The "Remove" & "Delete" Views
We need two more functions:

remove_cart: Decreases quantity by 1 (The "Minus" button).

remove_cart_item: Removes the product completely (The "Trash" button).

Add these to carts/views.py:

Python

def remove_cart(request, product_id):
    cart = Cart.objects.get(cart_id=_cart_id(request))
    product = get_object_or_404(Product, id=product_id)
    cart_item = CartItem.objects.get(product=product, cart=cart)
    
    if cart_item.quantity > 1:
        cart_item.quantity -= 1
        cart_item.save()
    else:
        cart_item.delete() # If only 1 left, remove it
    
    return redirect('cart')

def remove_cart_item(request, product_id):
    cart = Cart.objects.get(cart_id=_cart_id(request))
    product = get_object_or_404(Product, id=product_id)
    cart_item = CartItem.objects.get(product=product, cart=cart)
    
    cart_item.delete() # Hard delete
    return redirect('cart')
Step 3: The Cart View (Placeholder)
The redirect return redirect('cart') will fail if the view doesn't exist. Let's create a basic placeholder view.

Add to carts/views.py:

Python

def cart(request, total=0, quantity=0, cart_items=None):
    # This logic will be fleshed out in Day 7
    return render(request, 'store/cart.html') 
Step 4: The URLs
Create carts/urls.py:

Python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.cart, name='cart'),
    path('add_cart/<int:product_id>/', views.add_cart, name='add_cart'),
    path('remove_cart/<int:product_id>/', views.remove_cart, name='remove_cart'),
    path('remove_cart_item/<int:product_id>/', views.remove_cart_item, name='remove_cart_item'),
]
Update myproject/urls.py to include these:

Python

urlpatterns = [
    # ...
    path('cart/', include('carts.urls')), # Add this line
]
Step 5: Connect the Button
Now, go back to store/templates/store/product_detail.html. Find the "Add to Cart" button we made in Day 4 and update the href.

Before:

HTML

<a href="#" class="btn btn-primary">
After:

HTML

<a href="{% url 'add_cart' single_product.id %}" class="btn btn-primary">
Step 6: Verify Day 6
Run the server.

Go to a product detail page.

Click "Add to Cart".

Result: You will likely see a TemplateDoesNotExist error for store/cart.html (because we haven't built the cart page UI yet). This is good! It means the logic worked, it redirected you, and tried to load the page.

Check Admin: Go to http://127.0.0.1:8000/admin/carts/cartitem/. You should see the product listed there!

Great job. The backend logic is solid. Ready for Day 7? We will fix that TemplateDoesNotExist error by building the actual Shopping Cart Page with totals and taxes.

--------------------------------------------------------------------------------------------------------

Day 7 Goal: Build the Shopping Cart Page.

We need a page that lists what the user selected, allows them to change quantities ( + / - ), calculates the tax, and shows the final price.

You likely encountered a TemplateDoesNotExist error yesterday because this file was missing. Today, we fix that.

Step 1: The View Logic (Calculate Totals)
We need to make sure the math happens before the page loads.

Open carts/views.py.

Update your cart function to look like this. It fetches the items and calculates the bill.

Python

from django.shortcuts import render, redirect, get_object_or_404
from store.models import Product
from .models import Cart, CartItem
from django.core.exceptions import ObjectDoesNotExist

def cart(request, total=0, quantity=0, cart_items=None):
    try:
        tax = 0
        grand_total = 0
        # 1. Get the cart using the session ID
        cart = Cart.objects.get(cart_id=_cart_id(request))
        # 2. Get active items
        cart_items = CartItem.objects.filter(cart=cart, is_active=True)

        # 3. Loop to calculate totals
        for cart_item in cart_items:
            total += (cart_item.product.price * cart_item.quantity)
            quantity += cart_item.quantity

        # 4. Calculate Tax (e.g., 2%)
        tax = (2 * total) / 100
        grand_total = total + tax

    except ObjectDoesNotExist:
        pass # Just ignore if cart is empty

    context = {
        'total': total,
        'quantity': quantity,
        'cart_items': cart_items,
        'tax': tax,
        'grand_total': grand_total,
    }
    return render(request, 'store/cart.html', context)
Step 2: The Template (The UI)
Now create the file that was missing.

Create store/templates/store/cart.html.

Paste this code. It uses Bootstrap to make a clean table layout.

HTML

{% extends 'base.html' %}
{% load static %}

{% block content %}
<section class="section-content padding-y bg">
<div class="container">

{% if not cart_items %}
    <h2 class="text-center">Your Shopping Cart is Empty</h2>
    <br>
    <div class="text-center">
        <a href="{% url 'store' %}" class="btn btn-primary">Continue Shopping</a>
    </div>
{% else %}
<div class="row">
    <aside class="col-lg-9">
        <div class="card">
            <table class="table table-borderless table-shopping-cart">
                <thead class="text-muted">
                    <tr class="small text-uppercase">
                        <th scope="col">Product</th>
                        <th scope="col" width="120">Quantity</th>
                        <th scope="col" width="120">Price</th>
                        <th scope="col" class="text-right" width="200"> </th>
                    </tr>
                </thead>
                <tbody>
                    {% for cart_item in cart_items %}
                    <tr>
                        <td>
                            <figure class="itemside align-items-center">
                                <div class="aside"><img src="{{ cart_item.product.images.url }}" class="img-sm" style="width:80px;"></div>
                                <figcaption class="info">
                                    <a href="{{ cart_item.product.get_url }}" class="title text-dark">{{ cart_item.product.product_name }}</a>
                                    <p class="text-muted small">Category: {{ cart_item.product.category }}</p>
                                </figcaption>
                            </figure>
                        </td>
                        <td>
                            <div class="col">
                                <div class="input-group input-spinner">
                                    <div class="input-group-prepend">
                                        <a href="{% url 'remove_cart' cart_item.product.id %}" class="btn btn-light" type="button"> <i class="fa fa-minus">-</i> </a>
                                    </div>
                                    <input type="text" class="form-control"  value="{{ cart_item.quantity }}">
                                    <div class="input-group-append">
                                        <a href="{% url 'add_cart' cart_item.product.id %}" class="btn btn-light" type="button"> <i class="fa fa-plus">+</i> </a>
                                    </div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="price-wrap">
                                <var class="price">${{ cart_item.sub_total }}</var>
                                <small class="text-muted"> ${{ cart_item.product.price }} each </small>
                            </div> 
                        </td>
                        <td class="text-right">
                            <a href="{% url 'remove_cart_item' cart_item.product.id %}" onclick="return confirm('Are you sure you want to delete this item?')" class="btn btn-danger"> Remove</a>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div> 
    </aside> 

    <aside class="col-lg-3">
        <div class="card">
            <div class="card-body">
                <dl class="dlist-align">
                  <dt>Total price:</dt>
                  <dd class="text-right">${{ total }}</dd>
                </dl>
                <dl class="dlist-align">
                  <dt>Tax:</dt>
                  <dd class="text-right"> ${{ tax }}</dd>
                </dl>
                <dl class="dlist-align">
                  <dt>Total:</dt>
                  <dd class="text-right text-dark b"><strong>${{ grand_total }}</strong></dd>
                </dl>
                <hr>
                <p class="text-center mb-3">
                    <img src="{% static './images/misc/payments.png' %}" height="26">
                </p>
                <a href="{% url 'checkout' %}" class="btn btn-primary btn-block"> Checkout </a>
                <a href="{% url 'store' %}" class="btn btn-light btn-block">Continue Shopping</a>
            </div> 
        </div> 
    </aside> 
</div>
{% endif %}

</div> 
</section>
{% endblock %}
Step 3: Styling (Optional)
If the +/- buttons look ugly, it's because we need a tiny bit of CSS. You can add this to your base.html inside the <head> or <style> tag:

CSS

.input-spinner {
    max-width: 120px;
    flex-wrap: nowrap;
    display: flex;
}
.input-spinner input {
    text-align: center;
    max-width: 50px;
    flex-basis: 50px;
    border-color: #dee2e6;
    border-left: 0;
    border-right: 0;
}
.btn-light {
    background-color: #f8f9fa;
    border-color: #dee2e6;
}
Step 4: Verify Day 7
Run the server.

Go to the Store page.

Add an item (iPhone, etc.).

It should redirect you to /cart/.

Test the math:

Click +. Does the quantity go to 2? Does the price double?

Click -. Does the quantity drop?

Click Remove. Does the item disappear?

Does the "Total" match the sum of prices?

If this works, your Shopping Cart is 100% complete! Now users can browse and manage their basket.

Ready for Day 8? We will start building the Checkout Page where they enter their address.

----------------------------------------------------------------------------------------------------

This is the beginning of Phase 3: Checkout & Orders. This is the bridge between "Window Shopping" and "Actual Business."

Day 8 Goal: Create the Order Model and the Checkout Page (Form).

Note: We are slightly adjusting the roadmap order. In Django, it is best to build the Model first, then the Form, then the View. So we will tackle the Order Model today.

Step 1: The Order Model
We need a database table to store the shipping info and the final price.

Open orders/models.py.

Paste this code. It handles the customer's address and the order status.

Python

from django.db import models
from accounts.models import Account
from store.models import Product

class Order(models.Model):
    STATUS = (
        ('New', 'New'),
        ('Accepted', 'Accepted'),
        ('Completed', 'Completed'),
        ('Cancelled', 'Cancelled'),
    )

    user = models.ForeignKey(Account, on_delete=models.SET_NULL, null=True)
    order_number = models.CharField(max_length=20)
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    phone = models.CharField(max_length=15)
    email = models.EmailField(max_length=50)
    address_line_1 = models.CharField(max_length=50)
    address_line_2 = models.CharField(max_length=50, blank=True)
    country = models.CharField(max_length=50)
    state = models.CharField(max_length=50)
    city = models.CharField(max_length=50)
    order_note = models.CharField(max_length=100, blank=True)
    order_total = models.FloatField()
    tax = models.FloatField()
    status = models.CharField(max_length=10, choices=STATUS, default='New')
    ip = models.CharField(blank=True, max_length=20)
    is_ordered = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def full_name(self):
        return f'{self.first_name} {self.last_name}'

    def full_address(self):
        return f'{self.address_line_1} {self.address_line_2}'

    def __str__(self):
        return self.first_name
Sync the Database:

Bash

python manage.py makemigrations
python manage.py migrate
Step 2: The Order Form
Now that we have the Model, Django can build the form for us automatically.

Create a new file orders/forms.py.

Add this code:

Python

from django import forms
from .models import Order

class OrderForm(forms.ModelForm):
    class Meta:
        model = Order
        fields = ['first_name', 'last_name', 'phone', 'email', 'address_line_1', 'address_line_2', 'country', 'state', 'city', 'order_note']
Step 3: The Checkout View
This view is very similar to the cart view, but it also sends the OrderForm to the template so the user can fill it out.

Open carts/views.py.

Import the new form at the top:

Python

from orders.forms import OrderForm
Add the checkout function:

Python

def checkout(request, total=0, quantity=0, cart_items=None):
    try:
        cart = Cart.objects.get(cart_id=_cart_id(request))
        cart_items = CartItem.objects.filter(cart=cart, is_active=True)
        for cart_item in cart_items:
            total += (cart_item.product.price * cart_item.quantity)
            quantity += cart_item.quantity

        tax = (2 * total) / 100 # Assuming 2% tax
        grand_total = total + tax

    except ObjectDoesNotExist:
        pass # Just ignore if cart is empty

    context = {
        'total': total,
        'quantity': quantity,
        'cart_items': cart_items,
        'tax': tax,
        'grand_total': grand_total,
        'form': OrderForm(), # <--- Pass the empty form here
    }
    return render(request, 'store/checkout.html', context)
Step 4: The URL
Open carts/urls.py.

Add the path:

Python

path('checkout/', views.checkout, name='checkout'),
Step 5: The Template (The UI)
This is a big file because it has the Form on the left and the Cart Summary on the right.

Create store/templates/store/checkout.html.

Use this structure (Bootstrap grid):

HTML

{% extends 'base.html' %}
{% block content %}

<section class="section-content padding-y bg">
<div class="container">

<div class="row">
    <aside class="col-lg-6">
        <div class="card">
            <div class="card-body">
                <h4 class="card-title mb-4">Billing Address</h4>
                <form action="#" method="POST"> {% csrf_token %}
                    <div class="form-row row">
                        <div class="col form-group">
                            <label>First Name</label>
                            {{ form.first_name }} </div>
                        <div class="col form-group">
                            <label>Last Name</label>
                            {{ form.last_name }}
                        </div>
                    </div>
                    <div class="form-row row">
                        <div class="col form-group">
                            <label>Email</label>
                            {{ form.email }}
                        </div>
                        <div class="col form-group">
                            <label>Phone</label>
                            {{ form.phone }}
                        </div>
                    </div>
                     <div class="form-row row">
                        <div class="col form-group">
                            <label>Address Line 1</label>
                            {{ form.address_line_1 }}
                        </div>
                        <div class="col form-group">
                            <label>Address Line 2</label>
                            {{ form.address_line_2 }}
                        </div>
                    </div>
                     <div class="form-row row">
                        <div class="col form-group">
                            <label>City</label>
                            {{ form.city }}
                        </div>
                        <div class="col form-group">
                            <label>State</label>
                            {{ form.state }}
                        </div>
                         <div class="col form-group">
                            <label>Country</label>
                            {{ form.country }}
                        </div>
                    </div>
                    <div class="form-group">
                         <label>Order Note</label>
                         {{ form.order_note }}
                    </div>
            </div>
        </div> 
    </aside> 

    <aside class="col-lg-6">
        <div class="card">
            <div class="card-body">
                <table class="table table-borderless table-shopping-cart">
                    <thead class="text-muted">
                        <tr class="small text-uppercase">
                            <th scope="col">Product</th>
                            <th scope="col" width="120">Quantity</th>
                            <th scope="col" width="120">Price</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for cart_item in cart_items %}
                        <tr>
                            <td>
                                <figure class="itemside align-items-center">
                                    <div class="aside"><img src="{{ cart_item.product.images.url }}" class="img-sm" style="width:50px;"></div>
                                    <figcaption class="info">
                                        <a href="{{ cart_item.product.get_url }}" class="title text-dark">{{ cart_item.product.product_name }}</a>
                                    </figcaption>
                                </figure>
                            </td>
                            <td>
                                <label>{{cart_item.quantity}}</label>
                            </td>
                            <td>
                                <div class="price-wrap">
                                    <var class="price">${{ cart_item.sub_total }}</var>
                                </div>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
                <button type="submit" class="btn btn-primary btn-block">Place Order</button>
                <a href="{% url 'store' %}" class="btn btn-light btn-block">Continue Shopping</a>
                </form> </div> 
        </div> 
    </aside> 
</div> 
</div> 
</section>
{% endblock %}
Step 6: Update the Cart Button
Finally, go to store/templates/store/cart.html and make sure the "Checkout" button points to this new page.

HTML

<a href="{% url 'checkout' %}" class="btn btn-primary btn-block"> Checkout </a>
Step 7: Verify Day 8
Add items to your cart.

Click "Checkout".

Result: You should see a professional page.

Left Side: A form asking for Name, Address, City, etc.

Right Side: A summary of what you are buying.

Note on styling: The form fields might look plain (standard HTML inputs). To make them look like Bootstrap inputs, we usually add a widget tweak or a simple loop in the template, but functionality is key right now.

Ready for Day 9? We will handle the backend logic to actually save this order and move items from the "Cart" to the "Order" table.

----------------------------------------------------------------------------------------------------

Day 9 Goal: Handle the POST Request to save the Order to the database.

Currently, your "Place Order" button submits the form, but nothing happens. Today, we write the logic to catch that data, generate a unique Order Number, and save it as a "New" order in the database.

Step 1: The "Place Order" View
This is the brain of the operation. It will:

Check if the form is valid.

Create a new Order instance.

Generate a unique Order Number (e.g., 202310125 + Order ID).

Calculate the total price again (never trust the frontend price).

Redirect the user to a "Payment" page (which we will build next).

Create a new file orders/views.py (or open it if it exists) and add this code:

Python

from django.shortcuts import render, redirect
from django.http import HttpResponse
from carts.models import CartItem, Cart
from .forms import OrderForm
from .models import Order
import datetime

def place_order(request, total=0, quantity=0):
    current_user = request.user

    # 1. If the cart count is <= 0, redirect to store.
    cart_items = CartItem.objects.filter(user=current_user)
    cart_count = cart_items.count()
    if cart_count <= 0:
        return redirect('store')

    # 2. Handle the POST request
    if request.method == 'POST':
        form = OrderForm(request.POST)
        
        if form.is_valid():
            # Store all the billing info inside Order table
            data = Order()
            data.user = current_user
            data.first_name = form.cleaned_data['first_name']
            data.last_name = form.cleaned_data['last_name']
            data.phone = form.cleaned_data['phone']
            data.email = form.cleaned_data['email']
            data.address_line_1 = form.cleaned_data['address_line_1']
            data.address_line_2 = form.cleaned_data['address_line_2']
            data.country = form.cleaned_data['country']
            data.state = form.cleaned_data['state']
            data.city = form.cleaned_data['city']
            data.order_note = form.cleaned_data['order_note']
            data.order_total = 0 # Placeholder, we calculate below
            data.tax = 0         # Placeholder
            data.ip = request.META.get('REMOTE_ADDR')
            data.save() # Save to generate an ID

            # 3. Generate Order Number (Year + Month + Day + ID)
            yr = int(datetime.date.today().strftime('%Y'))
            dt = int(datetime.date.today().strftime('%d'))
            mt = int(datetime.date.today().strftime('%m'))
            d = datetime.date(yr,mt,dt)
            current_date = d.strftime("%Y%m%d")
            
            order_number = current_date + str(data.id)
            data.order_number = order_number
            data.save()

            # 4. Calculate Order Total
            cart_items = CartItem.objects.filter(user=current_user)
            for item in cart_items:
                total += (item.product.price * item.quantity)
                quantity += item.quantity
            
            tax = (2 * total)/100
            grand_total = total + tax
            
            data.order_total = grand_total
            data.tax = tax
            data.save()

            # 5. Send order data to the next page (Payment)
            order = Order.objects.get(user=current_user, is_ordered=False, order_number=order_number)
            context = {
                'order': order,
                'cart_items': cart_items,
                'total': total,
                'tax': tax,
                'grand_total': grand_total,
            }
            return render(request, 'orders/payments.html', context)
            
    else:
        return redirect('checkout')
Wait! A small fix is needed: In the code above, I used CartItem.objects.filter(user=current_user). However, our CartItem model currently links to Cart (session), not User.

Task: Open carts/models.py and add a user field to CartItem so we can track items by user.

Update carts/models.py:

Python

from accounts.models import Account # Import this

class CartItem(models.Model):
    user = models.ForeignKey(Account, on_delete=models.CASCADE, null=True) # <--- Add this
    # ... keep other fields ...
Run python manage.py makemigrations and migrate.

Step 2: The URL
We need to connect this view.

Create orders/urls.py:

Python

from django.urls import path
from . import views

urlpatterns = [
    path('place_order/', views.place_order, name='place_order'),
]
Update myproject/urls.py to include the orders app:

Python

path('orders/', include('orders.urls')),
Step 3: Connect the Form
Now tell the Checkout page to submit data to this new URL.

Open store/templates/store/checkout.html.

Find the <form> tag we fixed yesterday.

Change action from # to the new URL:

HTML

<form action="{% url 'place_order' %}" method="POST">
Step 4: The Payment Stub (Temporary)
The view tries to render orders/payments.html. We must create it to avoid an error, even if it's empty for now.

Create orders/templates/orders/payments.html.

Add this simple code:

HTML

{% extends 'base.html' %}
{% block content %}
<h1 class="text-center">Review Your Order</h1>
<h4 class="text-center">Order Number: {{ order.order_number }}</h4>
<h4 class="text-center">Total to Pay: ${{ grand_total }}</h4>
{% endblock %}
Step 5: Verify Day 9
Go to Cart -> Checkout.

Fill in the form (Use dummy data).

Click Place Order.

Success: You should be taken to the "Review Your Order" page.

Verify Database: Go to Admin -> Orders. You should see the new order there with the status "New".

Crucial Logic Check: Does the Order Number look correct? (e.g., 202302111...)? If yes, your order generation logic is perfect.

Ready for Day 10? We will finalize the "Move" logic—taking items out of the cart and locking them into the order permanently.

----------------------------------------------------------------------------------------------------

Gemini said
This is the most complex logic day, but completing it means you have a functioning e-commerce backend. We are bridging the gap between a temporary "Cart" and a permanent "Order."

Day 10 Goal: Implement the Order Placement Logic. This involves:

Payment Model: Storing transaction details.

OrderProduct Model: Creating a permanent snapshot of the items purchased.

Logic: Reducing stock, clearing the cart, and marking the order as "Complete."

Step 1: The Payment Model
We need to store the transaction details separately from the order itself.

Open orders/models.py.

Add this Payment model above the Order model (because Order will link to it):

Python
class Payment(models.Model):
    user = models.ForeignKey(Account, on_delete=models.CASCADE)
    payment_id = models.CharField(max_length=100)
    payment_method = models.CharField(max_length=100)
    amount_paid = models.CharField(max_length=100) # Total amount paid
    status = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.payment_id
Link Payment to Order: Now update your existing Order model to include a link to this Payment. Add this field inside your existing Order class:

Python
payment = models.ForeignKey(Payment, on_delete=models.SET_NULL, blank=True, null=True)
Sync Database:

Bash
python manage.py makemigrations
python manage.py migrate
Step 2: The OrderProduct Model
This table stores the items inside the order. It is crucial because it "freezes" the price. If you change the product price next week, this record ensures the old order keeps the old price.

Open orders/models.py.

Add this model at the bottom of the file:

Python
class OrderProduct(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    payment = models.ForeignKey(Payment, on_delete=models.SET_NULL, blank=True, null=True)
    user = models.ForeignKey(Account, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField()
    product_price = models.FloatField()
    ordered = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.product.product_name
Sync Database (Again):

Bash
python manage.py makemigrations
python manage.py migrate
Step 3: The Payment View (The Core Logic)
This view handles the "Success" event. Since we aren't using a real bank API (Stripe/PayPal) until Day 12, we will create a view that processes the data as if a payment succeeded.

Open orders/views.py.

Add imports at the top:

Python
import json
from django.http import JsonResponse
from .models import Order, Payment, OrderProduct
from store.models import Product
from carts.models import CartItem
from django.core.mail import EmailMessage
from django.template.loader import render_to_string
Add the payments function. This function does everything:

Python
def payments(request):
    body = json.loads(request.body)
    order = Order.objects.get(user=request.user, is_ordered=False, order_number=body['orderID'])

    # 1. Store Transaction Details inside Payment model
    payment = Payment(
        user = request.user,
        payment_id = body['transID'],
        payment_method = body['payment_method'],
        amount_paid = order.order_total,
        status = body['status'],
    )
    payment.save()

    # 2. Update the Order model (Mark as Ordered)
    order.payment = payment
    order.is_ordered = True
    order.save()

    # 3. Move the Cart Items to Order Product table
    cart_items = CartItem.objects.filter(user=request.user)

    for item in cart_items:
        orderproduct = OrderProduct()
        orderproduct.order_id = order.id
        orderproduct.payment = payment
        orderproduct.user_id = request.user.id
        orderproduct.product_id = item.product_id
        orderproduct.quantity = item.quantity
        orderproduct.product_price = item.product.price
        orderproduct.ordered = True
        orderproduct.save()

        # 4. Reduce the quantity of the sold products
        product = Product.objects.get(id=item.product_id)
        product.stock -= item.quantity
        product.save()

    # 5. Clear Cart
    CartItem.objects.filter(user=request.user).delete()

    # 6. Send data back to JS callback so it can redirect us
    data = {
        'order_number': order.order_number,
        'transID': payment.payment_id,
    }
    return JsonResponse(data)
Step 4: The JavaScript Trigger
We need a button that triggers this view. Since we are simulating a payment provider, we'll write a script that "mocks" a PayPal success response.

Open orders/templates/orders/payments.html.

Add this Script at the bottom of the page (after {% endblock %} is fine, or inside it):

HTML
<script>
    // 1. Helper to get CSRF token (Security)
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // 2. Setup Variables
    var amount = "{{ grand_total }}"
    var url = "{% url 'payments' %}"
    var csrftoken = getCookie('csrftoken');
    var orderID = "{{ order.order_number }}"
    var payment_method = 'PayPal'
    var redirect_url = "{% url 'order_complete' %}"

    // 3. Mock Payment Function (Triggered by button)
    function mockPayment() {
        sendData();
    }

    function sendData(){
        fetch(url, {
            method : "POST",
            headers: {
                "Content-type": "application/json",
                "X-CSRFToken": csrftoken,
            },
            body: JSON.stringify({
                orderID: orderID,
                transID: "MockTransaction" + Date.now(), // Fake ID
                payment_method: payment_method,
                status: "COMPLETED",
            }),
        })
        .then((response) => response.json())
        .then((data) => {
            // Redirect to success page
            window.location.href = redirect_url + '?order_number='+data.order_number+'&payment_id='+data.transID;
        });
    }
</script>
Add the button to your HTML body (where we left the comment yesterday):

HTML
<button onclick="mockPayment()" class="btn btn-primary btn-block">Pay Now (Simulate)</button>
Step 5: The "Order Complete" View & URL
Finally, the success page where users land.

Add View: In orders/views.py:

Python
def order_complete(request):
    order_number = request.GET.get('order_number')
    transID = request.GET.get('payment_id')

    try:
        order = Order.objects.get(order_number=order_number, is_ordered=True)
        ordered_products = OrderProduct.objects.filter(order_id=order.id)

        subtotal = 0
        for i in ordered_products:
            subtotal += i.product_price * i.quantity

        payment = Payment.objects.get(payment_id=transID)

        context = {
            'order': order,
            'ordered_products': ordered_products,
            'order_number': order.order_number,
            'transID': payment.payment_id,
            'payment': payment,
            'subtotal': subtotal,
        }
        return render(request, 'orders/order_complete.html', context)
    except (Payment.DoesNotExist, Order.DoesNotExist):
        return redirect('home')
Add URLs: In orders/urls.py, ensure these lines exist:

Python
path('payments/', views.payments, name='payments'),
path('order_complete/', views.order_complete, name='order_complete'),
Add Template: Create orders/templates/orders/order_complete.html. For now, just put: <h1>Thank you for your order! Order #{{ order_number }}</h1>

Step 6: Verify Day 10
Checkout -> Place Order.

Click "Pay Now (Simulate)".

Result Check:

Redirect: Did you go to the "Order Complete" page?

Stock: Go to Admin -> Products. Did the stock of the item decrease?

Cart: Is your cart now empty?

Database: Do you see a new Payment and OrderProduct in the admin?

You have successfully built the checkout backend! Ready for Day 11 (User Dashboard)?

-------------------------------------------------------------------------------------------------

